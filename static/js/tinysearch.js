// in page results when press enter or click search icon from search box
function closeSearchNow() {
    const main = document.querySelector("main");
    main.innerHTML = window.main
}
function goSearchNow() {
    const main = document.querySelector("main");
    if (!window.main) {
        window.main = main.innerHTML
    };
    var results = document.getElementById("suggestions");// suggestions div generated by search box

    var ResultsClone = results.cloneNode(true);// make a clone of the results, so that we can alter it
    ResultsClone.id = "results";// alter the id of our clone, so that we can apply different css style

    var headerDiv = document.createElement("div");// create a div element

    var headerContent = '<form name="closeSearch"><h2><button type="submit" title="Close Search"><i class="svgs x"></i></button> <i class="svgs search"></i> '.concat(document.getElementById("searchinput").value, "</h2></form>");// header to use at top of results page

    headerDiv.innerHTML = headerContent;// document element div (headerDiv), set the inner contents to our header html (headerContent)

    ResultsClone.insertBefore(headerDiv, ResultsClone.firstChild);//insert our header div at the top of the page

    main.innerHTML = ResultsClone.outerHTML;//display ResultsClone.outerHTML as the page
    results.innerHTML = "";// clear the suggestions div popup
    document.getElementById("searchinput").value = "";// clear the search input box
    document.body.contains(document.closeSearch) && (document.closeSearch.onsubmit = function() { closeSearchNow() })
    return false
}
var loaded = false;
window.onload = function() {
    document.body.contains(document.goSearch) && (document.goSearch.onsubmit = function() { return goSearchNow() })
    document.getElementById('searchinput').onfocus = function() {
        if (!loaded) {
            lazyLoad();
            loaded = true;
            document.body.contains(document.goSearch) && (document.goSearch.onsubmit = function() { return goSearchNow() })
        }
        document.getElementById('searchinput').onfocus = '';
    }
};

async function lazyLoad() {
    var baseUrl = document.querySelector("meta[name='base']").getAttribute("content");
    if (baseUrl.slice(-1) == "/") {
        baseUrl = baseUrl.slice(0, -1);
    }
    await init(baseUrl + "/tinysearch_engine_bg.wasm");
}

/* Close search suggestion popup list */
function closeAllLists(elmnt) {
    var suggestions = document.getElementById("suggestions");
    while (suggestions.firstChild) {
        suggestions.removeChild(suggestions.firstChild);
    }
}

function markTerm(input, term) {
    return input.replace(new RegExp('(^|)(' + term + ')(|$)','ig'), '$1<mark><b>$2</b></mark>$3');
}

function autocomplete(inp) {

    inp.addEventListener("input", function (e) {
        var suggestions, entry, i, val = this.value;

        /*close any already open lists of autocompleted values*/
        closeAllLists();
        if (!val) {
            return false;
        }

        suggestions = document.getElementById("suggestions");// suggestions div, generated by search box

        let arr = search(val, 99);//limit results

        for (i = 0; i < arr.length; i++) {
            let elem = arr[i];

            entry = document.createElement("DIV");
            entry.innerHTML = '<a href><span></span><span></span></a>';
            var a, t, d;
            a = entry.querySelector('a'),
            t = entry.querySelector('span:first-child'),
            d = entry.querySelector('span:nth-child(2)');
            a.href = `${elem[1]}?q=${encodeURIComponent(val)}`;//a link
            t.innerHTML = markTerm(elem[0], val);//title
            d.innerHTML = markTerm(elem[2], val);//description

            suggestions.appendChild(entry);
        }
    })
}
var searchinput = document.getElementById("searchinput");
function suggestionFocus(e) {
  if (e.keyCode === 191//forward slash
      && document.activeElement.tagName !== "INPUT"
      && document.activeElement.tagName !== "TEXTAREA") {
    e.preventDefault();
    searchinput.focus();
    suggestions.classList.remove('d-none');
  }

  if (e.keyCode === 27 ) {//escape
    searchinput.blur();
    suggestions.classList.add('d-none');
    closeAllLists();
  }

  const focusableSuggestions= suggestions.querySelectorAll('a');
  if (suggestions.classList.contains('d-none')
      || focusableSuggestions.length === 0) {
    return;
  }
  const focusable= [...focusableSuggestions];
  const index = focusable.indexOf(document.activeElement);

  let nextIndex = 0;

  if (e.keyCode === 38) {//up arrow
    e.preventDefault();
    nextIndex= index > 0 ? index-1 : 0;
    focusableSuggestions[nextIndex].focus();
  }
  else if (e.keyCode === 40) {//down arrow
    e.preventDefault();
    nextIndex= index+1 < focusable.length ? index+1 : index;
    focusableSuggestions[nextIndex].focus();
  }

}
document.addEventListener("keydown", suggestionFocus);

let wasm, cachedTextDecoder = (autocomplete(document.getElementById("searchinput")), new TextDecoder("utf-8", {
        ignoreBOM: !0,
        fatal: !0
    })),
    cachegetUint8Memory0 = (cachedTextDecoder.decode(), null);

function getUint8Memory0() {
    return cachegetUint8Memory0 = null !== cachegetUint8Memory0 && cachegetUint8Memory0.buffer === wasm.memory.buffer ? cachegetUint8Memory0 : new Uint8Array(wasm.memory.buffer)
}

function getStringFromWasm0(e, t) {
    return cachedTextDecoder.decode(getUint8Memory0().subarray(e, e + t))
}
const heap = new Array(32).fill(void 0);
heap.push(void 0, null, !0, !1);
let heap_next = heap.length;

function addHeapObject(e) {
    heap_next === heap.length && heap.push(heap.length + 1);
    var t = heap_next;
    return heap_next = heap[t], heap[t] = e, t
}
let WASM_VECTOR_LEN = 0,
    cachedTextEncoder = new TextEncoder("utf-8");
const encodeString = "function" == typeof cachedTextEncoder.encodeInto ? function(e, t) {
    return cachedTextEncoder.encodeInto(e, t)
} : function(e, t) {
    var n = cachedTextEncoder.encode(e);
    return t.set(n), {
        read: e.length,
        written: n.length
    }
};

function passStringToWasm0(e, t, n) {
    if (void 0 === n) {
        const n = cachedTextEncoder.encode(e),
            a = t(n.length);
        return getUint8Memory0().subarray(a, a + n.length).set(n), WASM_VECTOR_LEN = n.length, a
    }
    let a = e.length,
        o = t(a);
    const i = getUint8Memory0();
    let r = 0;
    for (; r < a; r++) {
        const t = e.charCodeAt(r);
        if (127 < t) break;
        i[o + r] = t
    }
    if (r !== a) {
        0 !== r && (e = e.slice(r)), o = n(o, a, a = r + 3 * e.length);
        const t = getUint8Memory0().subarray(o + r, o + a);
        r += encodeString(e, t).written
    }
    return WASM_VECTOR_LEN = r, o
}

function getObject(e) {
    return heap[e]
}

function dropObject(e) {
    e < 36 || (heap[e] = heap_next, heap_next = e)
}

function takeObject(e) {
    var t = getObject(e);
    return dropObject(e), t
}

function search(e, t) {
    var e = passStringToWasm0(e, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc),
        n = WASM_VECTOR_LEN;
    return takeObject(wasm.search(e, n, t))
}
async function load(e, t) {
    if ("function" == typeof Response && e instanceof Response) {
        if ("function" == typeof WebAssembly.instantiateStreaming) try {
            return await WebAssembly.instantiateStreaming(e, t)
        } catch (t) {
            if ("application/wasm" == e.headers.get("Content-Type")) throw t;
            console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", t)
        }
        var n = await e.arrayBuffer();
        return WebAssembly.instantiate(n, t)
    }
    n = await WebAssembly.instantiate(e, t);
    return n instanceof WebAssembly.Instance ? {
        instance: n,
        module: e
    } : n
}
async function init(e) {
    var baseUrl = document.querySelector("meta[name='base']").getAttribute("content");
    if (baseUrl.slice(-1) == "/") {
        baseUrl = baseUrl.slice(0, -1);
    }
    void 0 === e && (e = new URL(baseUrl + "/tinysearch_engine_bg.wasm"));
    const t = {
        wbg: {}
    };
    t.wbg.__wbindgen_json_parse = function(e, t) {
        return addHeapObject(JSON.parse(getStringFromWasm0(e, t)))
    };
    var {
        instance: e,
        module: n
    } = await load(await (e = "string" == typeof e || "function" == typeof Request && e instanceof Request || "function" == typeof URL && e instanceof URL ? fetch(e) : e), t);
    return wasm = e.exports, init.__wbindgen_wasm_module = n, wasm
}
